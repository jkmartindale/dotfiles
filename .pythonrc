# vim: syntax=python

import importlib
import os
import re
import sys
import types
from typing import Any, Callable, Tuple

# Accent color used for prompts and stuff
accent = 34

# Make prompts blue to make them easier to find in a sea of text
sys.ps1 = '\001\033[%sm\002>>>\001\033[0m\002 ' % accent
sys.ps2 = '\001\033[%sm\002...\001\033[0m\002 ' % accent

# Modified from https://github.com/pixelb/scripts/blob/master/scripts/inpy
def print_r(subject: dict) -> None:
    """Pretty-print a dict."""
    try:
        for key in sorted(subject.keys()):
            spacing = " " * (20 - (len(key) + 1))
            print('\001\033[%sm\002%s\001\033[0m\002 %s%s' % (accent - 2, key, spacing, subject[key]))
    except AttributeError:
        # Subject isn't subscriptable, so access attributes instead
        attributes = dir(subject)

        # Prevent accidental execution of commands
        if subject.__name__ == 'builtins':
            for command_name in Command.registry:
                attributes.remove(command_name)
        
        for attribute in attributes:
            spacing = " " * (20 - (len(attribute) + 1))
            print('\001\033[%s\002m%s\001\033[0m\002 %s%s' % (accent - 2, attribute, spacing, repr(getattr(subject, attribute))))

##########################
# Custom command framework
##########################

class Command(object):
    """A custom command to add to the interactive interpreter.

    No constructor arguments are used.
    """
    
    # List of command names registered by @command
    registry = []

    def __repr__(self) -> str:
        """Return a string when called as a statement."""
        return self.code()

    def __call__(self) -> None:
        """Print output when called as a function."""
        print(self.__repr__())

    def code(self) -> str:
        """Actual command code, typically set by @command."""
        # In case someone tries to make a Command from the interactive interpreter but forgets to set the code attribute
        return 'Set the code attribute to a callable returning a string.'

def command(function: Callable) -> None:
    """Convert a function to a Command.
    
    The function name is used as the command name. The function cannot take any arguments and must return a string.

    This function adds commands to __builtins__ and returns a string to protect against accidental execution when calling globals().
    """
    command = Command()
    command.code = function
    setattr(__builtins__, function.__name__, command)
    Command.registry.append(function.__name__)
    return 'Run enable_commands() to enable your commands.'

def enable_commands() -> None:
    """Enable registered commands for usage in the interactive shell.

    The ease of using @command has one trade-off: decorators must store a value in globals(). To prevent accidental execution, @command returns a string. However, the command names in globals() override the names in __builtins__, so this function removes them from globals().
    """
    for command in Command.registry:
        try:
            del globals()[command]
        except KeyError:
            # Command has already been removed from globals()
            pass

#################
# Define commands
#################

@command
def block() -> str:
    """Execute block input, such as pasted code."""
    print('\001\033[%dm\002Ctrl-D to run, Ctrl-C to cancel\001\033[0m\002' % accent)
    try:
        # Stolen from https://github.com/pixelb/scripts/blob/master/scripts/inpy
        exec(sys.stdin.read(), globals())
    except KeyboardInterrupt:
        # Don't output an error if cancelled
        pass
    # Start the next prompt on a new line instead of immediately after ^D or ^C
    return ''

@command
def exit() -> None:
    """Exit on `exit` instead of spitting out HURR DURR USE PARENTHESIS."""
    # ok, so I cheated a bit on the whole 'must return a string' thing
    raise SystemExit

@command
def pyrc() -> str:
    """Open the PYTHONSTARTUP file in the preferred editor."""
    if 'PYTHONSTARTUP' not in os.environ:
        return "The PYTHONSTARTUP environment variable hasn't been set."
    
    if os.system('${%s:-vim} $PYTHONSTARTUP' % ('VISUAL' if 'VISUAL' in os.environ else 'EDITOR')) == 0:
        return 'PYTHONSTARTUP opened in editor.'
    return 'Something happened.'

@command
def reload() -> str:
    """Reload the PYTHONSTARTUP file without exiting and re-entering the interactive interpreter."""
    try:
        with open(os.environ['PYTHONSTARTUP']) as profile:
            exec(profile.read(), globals())
    except FileNotFoundError:
        return "Couldn't find the file '%s'" % os.environ['PYTHONSTARTUP']
    except KeyError:
        return "The PYTHONSTARTUP environment variable hasn't been set."
    return 'PYTHONSTARTUP file reloaded'

###################################################
# Enable commands if you want them to actually work
###################################################

enable_commands()

################
# Exceptiom hook
################

def dynamic_import(module_name: str) -> None:
    """Import a module into sys.modules and globals"""
    module = importlib.import_module(module_name)
    # Prevent duplicate importing
    sys.modules[module_name] = module
    # Add to global scope
    globals()[module_name] = module

def exception_hook(exception_type: Exception, value: Exception, traceback: types.TracebackType) -> None:
    """Add a little functionality to Python's interpreter.
    
    - Output errors in red
    - Attempt to import unimported referenced modules
    - Minimal support for Python 2's print statement
    """
    # Make errors red
    sys.stderr.write('\001\033[91m\002')

    # Import unimported referenced modules
    if exception_type is NameError:
        name = re.match(r"name '(\w+)' is not defined", value.args[0])[1]
        try:
            dynamic_import(name)
            # Keep print call outside of dynamic_import() in case others want to use it
            print(name + ' imported, try again.')
            # Silence message
            return
        except ModuleNotFoundError:
            pass
    if exception_type is AttributeError:
        try:
            split = re.match(r"module '([\w.]+)' has no attribute '(\w+)'", value.args[0])
            module_name = split[1] + '.' + split[2]
            dynamic_import(module_name)
            # Keep print call outside of dynamic_import() in case others want to use it
            print(module_name + ' imported, try again.')
            # Silence message
            return
        except ModuleNotFoundError:
            pass

    # Enable minimal use of print statement
    if exception_type is SyntaxError:
        matches = re.match(r"print (.*)\n", value.text)
        if matches is not None:
            # Rewrite print statement to work
            exec('print(%s)' % matches[1])
            return

    # Run the default exception handling
    sys.__excepthook__(exception_type, value, traceback)
# Register hook
sys.excepthook = exception_hook
